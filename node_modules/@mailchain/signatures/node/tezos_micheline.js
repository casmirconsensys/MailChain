'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var utilCrypto = require('@polkadot/util-crypto');
var secp256k1 = require('secp256k1');

async function verifyTezosSignedMessage(key, msg, signature) {
    const messagePayload = createTezosSignedMessagePayload(msg);
    const bytesHash = utilCrypto.blake2AsU8a(messagePayload, 256);
    switch (key.curve) {
        case crypto.KindED25519:
        case crypto.KindSECP256R1:
            return key.verify(bytesHash, signature);
        case crypto.KindSECP256K1:
            return verifySpSignature(signature, bytesHash, key.bytes);
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}
function verifySpSignature(signature, message, publicKeyBytes) {
    try {
        return secp256k1.ecdsaVerify(signature, message, publicKeyBytes);
    }
    catch (e) {
        return false;
    }
}
function createTezosSignedMessagePayload(msg) {
    return formatAsTezosMicheline(encoding.decodeUtf8(`Tezos Signed Message: ${msg}`));
}
function formatAsTezosMicheline(payload) {
    const bytesLength = payload.length.toString(16);
    const addPadding = `00000000${bytesLength}`;
    const paddedBytesLength = addPadding.slice(addPadding.length - 8);
    return encoding.decodeHex('0501' + paddedBytesLength + encoding.encodeHex(payload));
}

exports.createTezosSignedMessagePayload = createTezosSignedMessagePayload;
exports.verifyTezosSignedMessage = verifyTezosSignedMessage;
