'use strict';

var secp256k1 = require('secp256k1');
var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');

async function verifyEthereumPersonalMessage(key, message, signature) {
    switch (key.curve) {
        case crypto.KindSECP256K1:
            // remove rec id if present
            if (signature.length === 65) {
                signature = signature.slice(0, -1);
            }
            const { hashMessage } = await import('@ethersproject/hash');
            const personalMessage = encoding.decodeHexZeroX(hashMessage(message));
            return secp256k1.ecdsaVerify(signature, Uint8Array.from(personalMessage), key.bytes);
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}
async function signEthereumPersonalMessage(key, message) {
    switch (key.curve) {
        case crypto.KindSECP256K1:
            const { hashMessage } = await import('@ethersproject/hash');
            const personalMessage = encoding.decodeHexZeroX(hashMessage(message));
            const sigObj = secp256k1.ecdsaSign(personalMessage, key.bytes);
            const ret = new Uint8Array(65);
            ret.set(sigObj.signature, 0);
            ret.set(new Uint8Array([sigObj.recid]), 64);
            return ret;
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}

exports.signEthereumPersonalMessage = signEthereumPersonalMessage;
exports.verifyEthereumPersonalMessage = verifyEthereumPersonalMessage;
