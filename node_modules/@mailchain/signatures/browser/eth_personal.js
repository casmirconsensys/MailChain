import { ecdsaVerify, ecdsaSign } from 'secp256k1';
import { ErrorUnsupportedKey, KindSECP256K1 } from '@mailchain/crypto';
import { decodeHexZeroX } from '@mailchain/encoding';

async function verifyEthereumPersonalMessage(key, message, signature) {
    switch (key.curve) {
        case KindSECP256K1:
            // remove rec id if present
            if (signature.length === 65) {
                signature = signature.slice(0, -1);
            }
            const { hashMessage } = await import('@ethersproject/hash');
            const personalMessage = decodeHexZeroX(hashMessage(message));
            return ecdsaVerify(signature, Uint8Array.from(personalMessage), key.bytes);
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}
async function signEthereumPersonalMessage(key, message) {
    switch (key.curve) {
        case KindSECP256K1:
            const { hashMessage } = await import('@ethersproject/hash');
            const personalMessage = decodeHexZeroX(hashMessage(message));
            const sigObj = ecdsaSign(personalMessage, key.bytes);
            const ret = new Uint8Array(65);
            ret.set(sigObj.signature, 0);
            ret.set(new Uint8Array([sigObj.recid]), 64);
            return ret;
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}

export { signEthereumPersonalMessage, verifyEthereumPersonalMessage };
