import { ErrorUnsupportedKey, KindSECP256K1, KindSECP256R1, KindED25519 } from '@mailchain/crypto';
import { decodeUtf8, decodeHex, encodeHex } from '@mailchain/encoding';
import { blake2AsU8a } from '@polkadot/util-crypto';
import { ecdsaVerify } from 'secp256k1';

async function verifyTezosSignedMessage(key, msg, signature) {
    const messagePayload = createTezosSignedMessagePayload(msg);
    const bytesHash = blake2AsU8a(messagePayload, 256);
    switch (key.curve) {
        case KindED25519:
        case KindSECP256R1:
            return key.verify(bytesHash, signature);
        case KindSECP256K1:
            return verifySpSignature(signature, bytesHash, key.bytes);
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}
function verifySpSignature(signature, message, publicKeyBytes) {
    try {
        return ecdsaVerify(signature, message, publicKeyBytes);
    }
    catch (e) {
        return false;
    }
}
function createTezosSignedMessagePayload(msg) {
    return formatAsTezosMicheline(decodeUtf8(`Tezos Signed Message: ${msg}`));
}
function formatAsTezosMicheline(payload) {
    const bytesLength = payload.length.toString(16);
    const addPadding = `00000000${bytesLength}`;
    const paddedBytesLength = addPadding.slice(addPadding.length - 8);
    return decodeHex('0501' + paddedBytesLength + encodeHex(payload));
}

export { createTezosSignedMessagePayload, verifyTezosSignedMessage };
