'use strict';

var convertKey = require('@polkadot/util-crypto/ed25519/convertKey');
var ids = require('../../multikey/ids.js');
var _private$1 = require('../../secp256k1/private.js');
var _private$2 = require('../../ed25519/private.js');
var _private = require('../../sr25519/private.js');
var serialization = require('./serialization.js');
var secretbox = require('./secretbox.js');

class PrivateKeyDecrypter {
    constructor(privateKey) {
        Object.defineProperty(this, "_secretKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_keyId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._keyId = ids.idFromPrivateKey(privateKey);
        switch (privateKey.constructor) {
            case _private$2.ED25519PrivateKey:
                this._secretKey = convertKey.convertSecretKeyToCurve25519(privateKey.bytes);
                break;
            case _private$1.SECP256K1PrivateKey:
                this._secretKey = privateKey.bytes;
                break;
            case _private.SR25519PrivateKey:
                throw RangeError('sr25519 key not supported'); // need to convert key to 32 bytes
            default:
                throw RangeError('unknown private key type');
        }
    }
    static fromPrivateKey(key) {
        return new this(key);
    }
    async decrypt(input) {
        const secretData = serialization.deserializePrivateKeyEncryptedContent(input);
        if (this._keyId !== secretData.keyId) {
            throw Error('key id does not match supplied key');
        }
        return secretbox.easyOpen(secretData.encryptedContent, this._secretKey);
    }
}

exports.PrivateKeyDecrypter = PrivateKeyDecrypter;
