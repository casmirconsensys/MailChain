'use strict';

var utilCrypto = require('@polkadot/util-crypto');
var ids = require('../../multikey/ids.js');
var rand = require('../../rand.js');
var _private$1 = require('../../secp256k1/private.js');
var _private$2 = require('../../ed25519/private.js');
var _private = require('../../sr25519/private.js');
var serialization = require('./serialization.js');
var secretbox = require('./secretbox.js');

class PrivateKeyEncrypter {
    constructor(privateKey, rand$1 = rand.secureRandom) {
        Object.defineProperty(this, "_rand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_secretKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_keyId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._rand = rand$1;
        this._keyId = ids.idFromPrivateKey(privateKey);
        switch (privateKey.constructor) {
            case _private$2.ED25519PrivateKey:
                this._secretKey = utilCrypto.convertSecretKeyToCurve25519(privateKey.bytes);
                break;
            case _private$1.SECP256K1PrivateKey:
                this._secretKey = privateKey.bytes;
                break;
            case _private.SR25519PrivateKey:
                throw RangeError('sr25519 key not supported'); // need to convert key to 32 bytes
            default:
                throw RangeError('unknown private key type');
        }
    }
    static fromPrivateKey(key, rand$1 = rand.secureRandom) {
        return new this(key, rand$1);
    }
    async encrypt(input) {
        const sealedBox = secretbox.easySeal(input, this._secretKey, this._rand);
        return serialization.serializePrivateKeyEncryptedContent(sealedBox, this._keyId);
    }
}

exports.PrivateKeyEncrypter = PrivateKeyEncrypter;
