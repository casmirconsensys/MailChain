'use strict';

var utilCrypto = require('@polkadot/util-crypto');
var rand = require('../rand.js');
var keys = require('../keys.js');
var mnemonic = require('../mnemonic/mnemonic.js');
var _public = require('./public.js');

const SR25519SecretKeyLength = 64;
const SR25519SeedLength = 32;
class SR25519PrivateKey {
    constructor(keyPair) {
        Object.defineProperty(this, "bytes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publicKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "keyPair", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "curve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keys.KindSR25519
        });
        if (keyPair.publicKey.length !== _public.SR25519PublicKeyLen) {
            throw new Error(`publicKey must be ${_public.SR25519PublicKeyLen} bytes`);
        }
        if (keyPair.secretKey.length !== SR25519SecretKeyLength) {
            throw new Error(`secretKey must be ${SR25519SecretKeyLength} bytes`);
        }
        this.keyPair = keyPair;
        // set bytes to the full key
        this.bytes = new Uint8Array(_public.SR25519PublicKeyLen + SR25519SecretKeyLength);
        this.bytes.set(keyPair.secretKey, 0);
        this.bytes.set(keyPair.publicKey, SR25519SecretKeyLength);
        this.publicKey = new _public.SR25519PublicKey(this.keyPair.publicKey);
    }
    static generate(rand$1 = rand.secureRandom) {
        return this.fromSeed(rand$1(SR25519SeedLength));
    }
    static async fromMnemonicPhrase(mnemonic$1, password) {
        return SR25519PrivateKey.fromSeed(mnemonic.toSeed(mnemonic$1, password, SR25519SeedLength));
    }
    static async fromSeed(bytes) {
        if (bytes.length !== SR25519SeedLength) {
            throw new Error('seed must be 32 byte');
        }
        const ready = await utilCrypto.cryptoWaitReady(); // needed before calling sr25519PairFromSeed
        if (!ready) {
            throw new Error('crypto libraries could not be initialized');
        }
        const keyPair = utilCrypto.sr25519PairFromSeed(bytes);
        return new this(keyPair);
    }
    static fromKeyPair(keyPair) {
        return new this(keyPair);
    }
    static fromBytes(bytes) {
        if (bytes.length !== _public.SR25519PublicKeyLen + SR25519SecretKeyLength) {
            throw new Error(`full key must be ${_public.SR25519PublicKeyLen + SR25519SecretKeyLength} bytes`);
        }
        return new this({
            secretKey: bytes.slice(0, SR25519SecretKeyLength),
            publicKey: bytes.slice(SR25519SecretKeyLength, _public.SR25519PublicKeyLen + SR25519SecretKeyLength),
        });
    }
    async sign(message) {
        const ready = await utilCrypto.cryptoWaitReady(); // needed before calling sr25519Sign
        if (!ready) {
            throw new Error('crypto libraries could not be initialized');
        }
        return utilCrypto.sr25519Sign(message, this.keyPair);
    }
}
function asSR25519PrivateKey(key) {
    if (key.constructor !== SR25519PrivateKey) {
        throw new Error('key must be sr25519');
    }
    return key;
}

exports.SR25519PrivateKey = SR25519PrivateKey;
exports.SR25519SecretKeyLength = SR25519SecretKeyLength;
exports.SR25519SeedLength = SR25519SeedLength;
exports.asSR25519PrivateKey = asSR25519PrivateKey;
