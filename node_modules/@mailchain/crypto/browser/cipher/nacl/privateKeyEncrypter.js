import { convertSecretKeyToCurve25519 } from '@polkadot/util-crypto';
import { idFromPrivateKey } from '../../multikey/ids.js';
import { secureRandom } from '../../rand.js';
import { SECP256K1PrivateKey } from '../../secp256k1/private.js';
import { ED25519PrivateKey } from '../../ed25519/private.js';
import { SR25519PrivateKey } from '../../sr25519/private.js';
import { serializePrivateKeyEncryptedContent } from './serialization.js';
import { easySeal } from './secretbox.js';

class PrivateKeyEncrypter {
    constructor(privateKey, rand = secureRandom) {
        Object.defineProperty(this, "_rand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_secretKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_keyId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._rand = rand;
        this._keyId = idFromPrivateKey(privateKey);
        switch (privateKey.constructor) {
            case ED25519PrivateKey:
                this._secretKey = convertSecretKeyToCurve25519(privateKey.bytes);
                break;
            case SECP256K1PrivateKey:
                this._secretKey = privateKey.bytes;
                break;
            case SR25519PrivateKey:
                throw RangeError('sr25519 key not supported'); // need to convert key to 32 bytes
            default:
                throw RangeError('unknown private key type');
        }
    }
    static fromPrivateKey(key, rand = secureRandom) {
        return new this(key, rand);
    }
    async encrypt(input) {
        const sealedBox = easySeal(input, this._secretKey, this._rand);
        return serializePrivateKeyEncryptedContent(sealedBox, this._keyId);
    }
}

export { PrivateKeyEncrypter };
