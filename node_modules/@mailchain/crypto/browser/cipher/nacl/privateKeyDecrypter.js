import { convertSecretKeyToCurve25519 } from '@polkadot/util-crypto/ed25519/convertKey';
import { idFromPrivateKey } from '../../multikey/ids.js';
import { SECP256K1PrivateKey } from '../../secp256k1/private.js';
import { ED25519PrivateKey } from '../../ed25519/private.js';
import { SR25519PrivateKey } from '../../sr25519/private.js';
import { deserializePrivateKeyEncryptedContent } from './serialization.js';
import { easyOpen } from './secretbox.js';

class PrivateKeyDecrypter {
    constructor(privateKey) {
        Object.defineProperty(this, "_secretKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_keyId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._keyId = idFromPrivateKey(privateKey);
        switch (privateKey.constructor) {
            case ED25519PrivateKey:
                this._secretKey = convertSecretKeyToCurve25519(privateKey.bytes);
                break;
            case SECP256K1PrivateKey:
                this._secretKey = privateKey.bytes;
                break;
            case SR25519PrivateKey:
                throw RangeError('sr25519 key not supported'); // need to convert key to 32 bytes
            default:
                throw RangeError('unknown private key type');
        }
    }
    static fromPrivateKey(key) {
        return new this(key);
    }
    async decrypt(input) {
        const secretData = deserializePrivateKeyEncryptedContent(input);
        if (this._keyId !== secretData.keyId) {
            throw Error('key id does not match supplied key');
        }
        return easyOpen(secretData.encryptedContent, this._secretKey);
    }
}

export { PrivateKeyDecrypter };
