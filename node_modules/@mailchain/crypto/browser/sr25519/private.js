import { cryptoWaitReady, sr25519PairFromSeed, sr25519Sign } from '@polkadot/util-crypto';
import { secureRandom } from '../rand.js';
import { KindSR25519 } from '../keys.js';
import { toSeed } from '../mnemonic/mnemonic.js';
import { SR25519PublicKeyLen, SR25519PublicKey } from './public.js';

const SR25519SecretKeyLength = 64;
const SR25519SeedLength = 32;
class SR25519PrivateKey {
    constructor(keyPair) {
        Object.defineProperty(this, "bytes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publicKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "keyPair", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "curve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: KindSR25519
        });
        if (keyPair.publicKey.length !== SR25519PublicKeyLen) {
            throw new Error(`publicKey must be ${SR25519PublicKeyLen} bytes`);
        }
        if (keyPair.secretKey.length !== SR25519SecretKeyLength) {
            throw new Error(`secretKey must be ${SR25519SecretKeyLength} bytes`);
        }
        this.keyPair = keyPair;
        // set bytes to the full key
        this.bytes = new Uint8Array(SR25519PublicKeyLen + SR25519SecretKeyLength);
        this.bytes.set(keyPair.secretKey, 0);
        this.bytes.set(keyPair.publicKey, SR25519SecretKeyLength);
        this.publicKey = new SR25519PublicKey(this.keyPair.publicKey);
    }
    static generate(rand = secureRandom) {
        return this.fromSeed(rand(SR25519SeedLength));
    }
    static async fromMnemonicPhrase(mnemonic, password) {
        return SR25519PrivateKey.fromSeed(toSeed(mnemonic, password, SR25519SeedLength));
    }
    static async fromSeed(bytes) {
        if (bytes.length !== SR25519SeedLength) {
            throw new Error('seed must be 32 byte');
        }
        const ready = await cryptoWaitReady(); // needed before calling sr25519PairFromSeed
        if (!ready) {
            throw new Error('crypto libraries could not be initialized');
        }
        const keyPair = sr25519PairFromSeed(bytes);
        return new this(keyPair);
    }
    static fromKeyPair(keyPair) {
        return new this(keyPair);
    }
    static fromBytes(bytes) {
        if (bytes.length !== SR25519PublicKeyLen + SR25519SecretKeyLength) {
            throw new Error(`full key must be ${SR25519PublicKeyLen + SR25519SecretKeyLength} bytes`);
        }
        return new this({
            secretKey: bytes.slice(0, SR25519SecretKeyLength),
            publicKey: bytes.slice(SR25519SecretKeyLength, SR25519PublicKeyLen + SR25519SecretKeyLength),
        });
    }
    async sign(message) {
        const ready = await cryptoWaitReady(); // needed before calling sr25519Sign
        if (!ready) {
            throw new Error('crypto libraries could not be initialized');
        }
        return sr25519Sign(message, this.keyPair);
    }
}
function asSR25519PrivateKey(key) {
    if (key.constructor !== SR25519PrivateKey) {
        throw new Error('key must be sr25519');
    }
    return key;
}

export { SR25519PrivateKey, SR25519SecretKeyLength, SR25519SeedLength, asSR25519PrivateKey };
