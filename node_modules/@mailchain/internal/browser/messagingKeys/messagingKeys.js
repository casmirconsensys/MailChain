import { encodeHexZeroX } from '@mailchain/encoding';
import { encodeAddressByProtocol, ALL_PROTOCOLS, ProtocolNotSupportedError } from '@mailchain/addressing';
import { encodePublicKey } from '@mailchain/crypto';
import { AddressesApiFactory, createAxiosConfiguration, IdentityKeysApiFactory, encodingTypeToEncodingEnum, CryptoKeyConvert } from '@mailchain/api';
import { convertPublic } from '@mailchain/api/browser/helpers/apiKeyToCryptoKey';
import { isAxiosError } from 'axios';
import { NameserviceAddressUnresolvableError, NameserviceAddressNotFoundError, UnexpectedMailchainError } from './errors.js';
import { MessagingKeyContractCall } from './messagingKeyContract.js';
import { partitionMailchainResults } from '../mailchainResult.js';

class SomeAddressesUnresolvableError extends Error {
    constructor(successes, failures) {
        super(`Not all addresses were resolved. Check the failed resolutions for more information.`);
        Object.defineProperty(this, "successes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: successes
        });
        Object.defineProperty(this, "failures", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: failures
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'not_all_addresses_resolved'
        });
    }
}
class MessagingKeys {
    constructor(addressApi, identityKeysApi, messagingKeyContractCall) {
        Object.defineProperty(this, "addressApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressApi
        });
        Object.defineProperty(this, "identityKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysApi
        });
        Object.defineProperty(this, "messagingKeyContractCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeyContractCall
        });
    }
    static create(configuration) {
        return new MessagingKeys(AddressesApiFactory(createAxiosConfiguration(configuration.apiPath)), IdentityKeysApiFactory(createAxiosConfiguration(configuration.apiPath)), MessagingKeyContractCall.create(configuration));
    }
    /**
     * Resolve the messaging key for the given address.
     *
     * @param address Address to resolve.
     *
     * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
     *
     * @example
     * import { messagingKeys } from '@mailchain/sdk';
     *
     * const resolvedAddress = await messagingKeys.resolve(address);
     * console.log(resolvedAddress);
     *
     */
    async resolve(address) {
        const { data, error } = await this.getAddressMessagingKey(address);
        if (error != null) {
            return { error };
        }
        return this.messagingKeyContractCall.resolve(data.protocol, data.contractCall, data.identityKey ? convertPublic(data.identityKey) : undefined);
    }
    async resolveMany(addresses) {
        const deduplicatedAddresses = [...new Set(addresses)];
        const resolvedAddresses = await Promise.all(deduplicatedAddresses.map(async (address) => {
            const resolvedAddress = await this.resolve(address);
            return { params: address, result: resolvedAddress };
        }));
        const { failures, successes } = partitionMailchainResults(resolvedAddresses);
        if (failures.length > 0) {
            return { error: new SomeAddressesUnresolvableError(successes, failures) };
        }
        return {
            data: new Map(successes.map((r) => [r.params, r.data])),
        };
    }
    async update(proof) {
        const encodedIdentityKey = encodeHexZeroX(encodePublicKey(proof.identityKey));
        const encodedAddress = encodeAddressByProtocol(proof.address, proof.protocol);
        await this.identityKeysApi.putMsgKeyByIDKey(encodedIdentityKey, {
            address: {
                encoding: encodingTypeToEncodingEnum(encodedAddress.encoding),
                value: encodedAddress.encoded,
                network: proof.network,
                protocol: proof.protocol,
            },
            locale: proof.locale,
            messageVariant: proof.messageVariant,
            messagingKey: CryptoKeyConvert.public(proof.messagingKey),
            nonce: proof.nonce,
            signature: encodeHexZeroX(proof.signature),
            signatureMethod: proof.signatureMethod,
        });
    }
    async getAddressMessagingKey(address) {
        var _a;
        try {
            const { data } = await this.addressApi.getAddressMessagingKey(address);
            const protocol = data.protocol;
            if (!ALL_PROTOCOLS.includes(protocol)) {
                return { error: new ProtocolNotSupportedError(protocol) };
            }
            return { data };
        }
        catch (e) {
            if (isAxiosError(e)) {
                switch ((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) {
                    case 404:
                        return {
                            error: new NameserviceAddressNotFoundError(),
                        };
                    case 422:
                        return {
                            error: new NameserviceAddressUnresolvableError(),
                        };
                }
            }
            return {
                error: new UnexpectedMailchainError(`Failed to resolve messaging key of address ${address}`, e),
            };
        }
    }
}

export { MessagingKeys, SomeAddressesUnresolvableError };
