import { encodePublicKey, isPublicKeyEqual } from '@mailchain/crypto';
import { encodeHexZeroX } from '@mailchain/encoding';
import { ETHEREUM, TEZOS, createNameServiceAddress } from '@mailchain/addressing';
import { NAMESERVICE_DESCRIPTIONS } from '@mailchain/addressing/browser/nameservices';
import { IdentityKeysApiFactory, createAxiosConfiguration } from '@mailchain/api';
import { IdentityKeys } from '../identityKeys/identityKeys.js';

const PROTOCOLS_SUPPORTING_NAMESERVICE = [ETHEREUM, TEZOS];
class Nameservices {
    constructor(identityKeysApi, identityKeysService, mailchainAddressDomain) {
        Object.defineProperty(this, "identityKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysApi
        });
        Object.defineProperty(this, "identityKeysService", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysService
        });
        Object.defineProperty(this, "mailchainAddressDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailchainAddressDomain
        });
    }
    static create(config) {
        const identityKeysApi = IdentityKeysApiFactory(createAxiosConfiguration(config.apiPath));
        const identityKeysService = IdentityKeys.create(config);
        return new Nameservices(identityKeysApi, identityKeysService, config.mailchainAddressDomain);
    }
    async reverseResolveNames(identityKey) {
        return this.identityKeysApi.getIdentityKeyResolvableNames(encodeHexZeroX(encodePublicKey(identityKey))).then(({ data }) => {
            var _a, _b;
            return (_b = (_a = data.resolvableNames) === null || _a === void 0 ? void 0 : _a.map((resolved) => (Object.assign(Object.assign({}, resolved), { address: createNameServiceAddress(resolved.name, resolved.resolver, this.mailchainAddressDomain) })))) !== null && _b !== void 0 ? _b : [];
        }, (e) => {
            console.error(e);
            return [];
        });
    }
    async nameResolvesToMailbox(nsName, mailboxIdentityKey) {
        for (const nsDesc of NAMESERVICE_DESCRIPTIONS) {
            const nsAddress = createNameServiceAddress(nsName, nsDesc.name, this.mailchainAddressDomain);
            const addressIdentityKey = await this.identityKeysService.getAddressIdentityKey(nsAddress);
            if (addressIdentityKey != null && isPublicKeyEqual(addressIdentityKey.identityKey, mailboxIdentityKey)) {
                return nsAddress;
            }
        }
        return null;
    }
}

export { Nameservices, PROTOCOLS_SUPPORTING_NAMESERVICE };
