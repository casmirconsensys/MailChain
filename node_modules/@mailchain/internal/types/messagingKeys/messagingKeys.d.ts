import { ProtocolNotSupportedError, ProtocolType } from '@mailchain/addressing';
import { PublicKey } from '@mailchain/crypto';
import { IdentityKeysApiInterface, AddressesApiInterface } from '@mailchain/api';
import { MessagingKeyVerificationError } from '@mailchain/signatures';
import { Configuration } from '@mailchain/internal/types/configuration';
import { MailchainResult } from '@mailchain/internal';
import { MessagingKeyContactError, NameserviceAddressNotFoundError, NameserviceAddressUnresolvableError, UnexpectedMailchainError } from '@mailchain/internal/types/messagingKeys/errors';
import { MessagingKeyProof } from '@mailchain/internal/types/messagingKeys/proof';
import { MessagingKeyContractCall } from '@mailchain/internal/types/messagingKeys/messagingKeyContract';
type BaseResolvedAddress = {
    /** Messaging key to be used when communicate with the resolved address. See {@link PublicKey} */
    messagingKey: PublicKey;
    /** Protocol of resolved address. Protocol is determined when resolving the address. */
    protocol: ProtocolType;
    /** Identity key of resolved address. Identity key might be undefined in the case of `vended` messaging key. */
    identityKey?: PublicKey;
    /** Protocol address that has been resolved in the case of name services. */
    protocolAddress: string;
};
export type RegisteredResolvedAddress = BaseResolvedAddress & {
    /** Indicates the messaging key has been registered by a user. */
    type: 'registered';
};
export type VendedResolvedAddress = BaseResolvedAddress & {
    /** Indicates the messaging key has been vended by Mailchain. */
    type: 'vended';
};
/**
 * Resolved address response containing a proven messaging key.
 */
export type ResolvedAddress = RegisteredResolvedAddress | VendedResolvedAddress;
export type ResolveAddressError = ProtocolNotSupportedError | MessagingKeyContactError | MessagingKeyVerificationError | NameserviceAddressNotFoundError | NameserviceAddressUnresolvableError | UnexpectedMailchainError;
export type ResolveAddressResult = MailchainResult<ResolvedAddress, ResolveAddressError>;
export type ResolvedManyAddresses = Map<string, ResolvedAddress>;
export type ResolvedManyAddressesResult = MailchainResult<ResolvedManyAddresses>;
export type ResolveManyAddressesError = SomeAddressesUnresolvableError;
export declare class SomeAddressesUnresolvableError extends Error {
    readonly successes: Array<{
        params: string;
        data: ResolvedAddress;
    }>;
    readonly failures: Array<{
        params: string;
        error: ResolveAddressError;
    }>;
    readonly type = "not_all_addresses_resolved";
    constructor(successes: Array<{
        params: string;
        data: ResolvedAddress;
    }>, failures: Array<{
        params: string;
        error: ResolveAddressError;
    }>);
}
export declare class MessagingKeys {
    private readonly addressApi;
    private readonly identityKeysApi;
    private readonly messagingKeyContractCall;
    constructor(addressApi: AddressesApiInterface, identityKeysApi: IdentityKeysApiInterface, messagingKeyContractCall: MessagingKeyContractCall);
    static create(configuration: Configuration): MessagingKeys;
    /**
     * Resolve the messaging key for the given address.
     *
     * @param address Address to resolve.
     *
     * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
     *
     * @example
     * import { messagingKeys } from '@mailchain/sdk';
     *
     * const resolvedAddress = await messagingKeys.resolve(address);
     * console.log(resolvedAddress);
     *
     */
    resolve(address: string): Promise<ResolveAddressResult>;
    resolveMany(addresses: string[]): Promise<MailchainResult<ResolvedManyAddresses, ResolveManyAddressesError>>;
    update(proof: MessagingKeyProof): Promise<void>;
    private getAddressMessagingKey;
}
export {};
