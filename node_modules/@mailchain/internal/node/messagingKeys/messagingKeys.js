'use strict';

var encoding = require('@mailchain/encoding');
var addressing = require('@mailchain/addressing');
var crypto = require('@mailchain/crypto');
var api = require('@mailchain/api');
var apiKeyToCryptoKey = require('@mailchain/api/node/helpers/apiKeyToCryptoKey');
var axios = require('axios');
var errors = require('./errors.js');
var messagingKeyContract = require('./messagingKeyContract.js');
var mailchainResult = require('../mailchainResult.js');

class SomeAddressesUnresolvableError extends Error {
    constructor(successes, failures) {
        super(`Not all addresses were resolved. Check the failed resolutions for more information.`);
        Object.defineProperty(this, "successes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: successes
        });
        Object.defineProperty(this, "failures", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: failures
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'not_all_addresses_resolved'
        });
    }
}
class MessagingKeys {
    constructor(addressApi, identityKeysApi, messagingKeyContractCall) {
        Object.defineProperty(this, "addressApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressApi
        });
        Object.defineProperty(this, "identityKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysApi
        });
        Object.defineProperty(this, "messagingKeyContractCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeyContractCall
        });
    }
    static create(configuration) {
        return new MessagingKeys(api.AddressesApiFactory(api.createAxiosConfiguration(configuration.apiPath)), api.IdentityKeysApiFactory(api.createAxiosConfiguration(configuration.apiPath)), messagingKeyContract.MessagingKeyContractCall.create(configuration));
    }
    /**
     * Resolve the messaging key for the given address.
     *
     * @param address Address to resolve.
     *
     * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
     *
     * @example
     * import { messagingKeys } from '@mailchain/sdk';
     *
     * const resolvedAddress = await messagingKeys.resolve(address);
     * console.log(resolvedAddress);
     *
     */
    async resolve(address) {
        const { data, error } = await this.getAddressMessagingKey(address);
        if (error != null) {
            return { error };
        }
        return this.messagingKeyContractCall.resolve(data.protocol, data.contractCall, data.identityKey ? apiKeyToCryptoKey.convertPublic(data.identityKey) : undefined);
    }
    async resolveMany(addresses) {
        const deduplicatedAddresses = [...new Set(addresses)];
        const resolvedAddresses = await Promise.all(deduplicatedAddresses.map(async (address) => {
            const resolvedAddress = await this.resolve(address);
            return { params: address, result: resolvedAddress };
        }));
        const { failures, successes } = mailchainResult.partitionMailchainResults(resolvedAddresses);
        if (failures.length > 0) {
            return { error: new SomeAddressesUnresolvableError(successes, failures) };
        }
        return {
            data: new Map(successes.map((r) => [r.params, r.data])),
        };
    }
    async update(proof) {
        const encodedIdentityKey = encoding.encodeHexZeroX(crypto.encodePublicKey(proof.identityKey));
        const encodedAddress = addressing.encodeAddressByProtocol(proof.address, proof.protocol);
        await this.identityKeysApi.putMsgKeyByIDKey(encodedIdentityKey, {
            address: {
                encoding: api.encodingTypeToEncodingEnum(encodedAddress.encoding),
                value: encodedAddress.encoded,
                network: proof.network,
                protocol: proof.protocol,
            },
            locale: proof.locale,
            messageVariant: proof.messageVariant,
            messagingKey: api.CryptoKeyConvert.public(proof.messagingKey),
            nonce: proof.nonce,
            signature: encoding.encodeHexZeroX(proof.signature),
            signatureMethod: proof.signatureMethod,
        });
    }
    async getAddressMessagingKey(address) {
        var _a;
        try {
            const { data } = await this.addressApi.getAddressMessagingKey(address);
            const protocol = data.protocol;
            if (!addressing.ALL_PROTOCOLS.includes(protocol)) {
                return { error: new addressing.ProtocolNotSupportedError(protocol) };
            }
            return { data };
        }
        catch (e) {
            if (axios.isAxiosError(e)) {
                switch ((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) {
                    case 404:
                        return {
                            error: new errors.NameserviceAddressNotFoundError(),
                        };
                    case 422:
                        return {
                            error: new errors.NameserviceAddressUnresolvableError(),
                        };
                }
            }
            return {
                error: new errors.UnexpectedMailchainError(`Failed to resolve messaging key of address ${address}`, e),
            };
        }
    }
}

exports.MessagingKeys = MessagingKeys;
exports.SomeAddressesUnresolvableError = SomeAddressesUnresolvableError;
