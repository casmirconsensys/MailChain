'use strict';

var addressing = require('@mailchain/addressing');
var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var messageComposer = require('@mailchain/message-composer');
var consts = require('./consts.js');
var simpleMimeHeaderParser = require('./simpleMimeHeaderParser.js');

function decodeNodeContent(node) {
    var _a, _b, _c, _d, _e;
    const [, rawContent] = node.raw.split('\n\n');
    let decodedContent = null;
    if (node.contentTransferEncoding) {
        switch (node.contentTransferEncoding.value.toLowerCase()) {
            case 'base64':
                decodedContent = encoding.decodeBase64(rawContent);
                break;
            case '7bit':
                // Simple 7-bit ASCII, no decoding and processing needed
                try {
                    // Note: the `decodeURIComponent` is legacy leftover to handle legacy implementation the characters were encoded using encodeURIComponent
                    return decodeURIComponent(rawContent);
                }
                catch (e) {
                    return rawContent;
                }
            default:
                throw new Error(`unsupported content transfer encoding [${node.contentTransferEncoding.value}]`);
        }
    }
    if (decodedContent == null) {
        throw new Error('could not extract decodedContent from rawContent');
    }
    switch ((_c = (_b = (_a = node.contentType) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.charset) === null || _c === void 0 ? void 0 : _c.toUpperCase()) {
        case 'UTF-8':
            return encoding.encodeUtf8(decodedContent);
        case undefined:
            return decodedContent;
        default:
            throw new Error(`unsupported content charset [${(_e = (_d = node.contentType) === null || _d === void 0 ? void 0 : _d.params) === null || _e === void 0 ? void 0 : _e.charset}]`);
    }
}
function extractContent(nodes) {
    var _a, _b;
    const extracted = { messages: {}, attachments: [] };
    for (const node of nodes) {
        const { contentType, headers } = node;
        if ((contentType === null || contentType === void 0 ? void 0 : contentType.value) === 'multipart/alternative') {
            const childContent = extractContent(node.childNodes);
            extracted.messages = Object.assign(Object.assign({}, childContent.messages), extracted.messages);
            // Note: there probably won't be attachments in multipart/alternative
            extracted.attachments = [...extracted.attachments, ...childContent.attachments];
        }
        else if ((contentType === null || contentType === void 0 ? void 0 : contentType.value) === 'text/plain' || (contentType === null || contentType === void 0 ? void 0 : contentType.value) === 'text/html') {
            const content = decodeNodeContent(node);
            if (typeof content !== 'string')
                throw new Error('cannot process message content being non-string');
            extracted.messages = Object.assign(Object.assign({}, extracted.messages), { [contentType.value]: content });
        }
        else if (((_b = (_a = headers['content-disposition']) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.value) === 'attachment') {
            // TODO: This is some attachment WIP code, it doesn't work!
            const content = decodeNodeContent(node);
            if (typeof content === 'string')
                throw new Error('cannot process attachment content being string');
            extracted.attachments.push(content);
        }
    }
    return extracted;
}
async function parseMimeText(content) {
    var _a, _b;
    const parse = (await import('emailjs-mime-parser')).default;
    const text = content.toString('utf-8');
    const headersMap = simpleMimeHeaderParser.simpleMimeHeaderParser(text);
    const parsedParticipants = await parseParticipants(headersMap);
    const parsedMessage = parse(text);
    const { headers } = parsedMessage;
    const addressIdentityKeys = parseIdentityKeys((_a = headersMap.get(consts.X_IDENTITY_KEYS)) !== null && _a !== void 0 ? _a : '');
    const extractedContent = parsedMessage.childNodes.length > 0
        ? extractContent(parsedMessage.childNodes)
        : extractContent([parsedMessage]);
    const mailData = Object.assign(Object.assign({ id: parseMessageId(headers['message-id'][0].initial), date: new Date(headers['date'][0].value) }, parsedParticipants), { subject: parseSubjectHeader((_b = headers.subject) === null || _b === void 0 ? void 0 : _b[0].initial), plainTextMessage: extractedContent.messages['text/plain'], message: extractedContent.messages['text/html'] });
    return { mailData, addressIdentityKeys };
}
async function parseParticipants(headers) {
    var _a, _b;
    const { parseOneAddress, parseAddressList } = (await import('email-addresses')).default;
    const fromValue = headers.get(messageComposer.HEADER_LABELS.From);
    const parsedFrom = parseOneAddress({ input: fromValue !== null && fromValue !== void 0 ? fromValue : '', rfc6532: true, rejectTLD: true });
    if (parsedFrom == null)
        throw new Error(`message doesn't include valid 'from' header field [${fromValue}]`);
    const from = isParsedMailbox(parsedFrom)
        ? { name: (_a = parsedFrom.name) !== null && _a !== void 0 ? _a : '', address: parsedFrom.address }
        : { name: parsedFrom.name, address: parsedFrom.addresses[0].address };
    const replyTooValue = headers.get(messageComposer.HEADER_LABELS.ReplyTo);
    const parsedReplyTo = parseOneAddress({ input: replyTooValue !== null && replyTooValue !== void 0 ? replyTooValue : '', rfc6532: true, rejectTLD: true });
    let replyTo = undefined;
    if (parsedReplyTo != null) {
        replyTo = isParsedMailbox(parsedReplyTo)
            ? { name: (_b = parsedReplyTo.name) !== null && _b !== void 0 ? _b : '', address: parsedReplyTo.address }
            : { name: parsedReplyTo.name, address: parsedReplyTo.addresses[0].address };
    }
    function parseAddresses(headerLabel) {
        var _a, _b;
        const result = [];
        const headerValue = headers.get(headerLabel);
        if (headerValue != null) {
            const parsedAddresses = (_a = parseAddressList({ input: headerValue, rfc6532: true, rejectTLD: true })) !== null && _a !== void 0 ? _a : [];
            for (const address of parsedAddresses) {
                if (isParsedMailbox(address)) {
                    result.push({ name: (_b = address.name) !== null && _b !== void 0 ? _b : '', address: address.address });
                }
                else {
                    result.push(...address.addresses.map((a) => { var _a; return ({ name: (_a = a.name) !== null && _a !== void 0 ? _a : address.name, address: a.address }); }));
                }
            }
        }
        return result;
    }
    const recipients = parseAddresses(messageComposer.HEADER_LABELS.To);
    const carbonCopyRecipients = parseAddresses(messageComposer.HEADER_LABELS.Cc);
    const blindCarbonCopyRecipients = parseAddresses(messageComposer.HEADER_LABELS.Bcc);
    return { from, replyTo, recipients, carbonCopyRecipients, blindCarbonCopyRecipients };
}
function isParsedMailbox(mailboxOrGroup) {
    return mailboxOrGroup.type === 'mailbox';
}
function parseMessageId(messageIdHeader) {
    if (messageIdHeader.startsWith('<') && messageIdHeader.endsWith('>')) {
        return messageIdHeader.slice(1, -1);
    }
    return messageIdHeader;
}
function parseSubjectHeader(rawSubject) {
    // Handle case when the subject header is not encoded
    if (!rawSubject.startsWith('=?'))
        return rawSubject;
    const lines = rawSubject.split('\t');
    // https://dmorgan.info/posts/encoded-word-syntax/
    // tl;dr if the subject conitans non ASCII characters, the subject is base64 encoded
    // Sample value: =?UTF-8?B?ZnVjayDwn5CO?=!
    // Parts: =?<charset>?<encoding>?<encoded-text>?=
    let encodedContent = '';
    let contentEncoding = null;
    let contentCharset = null;
    for (const line of lines) {
        const [, charset, encoding, encodedText] = line.split('?');
        if (contentEncoding == null) {
            contentEncoding = encoding;
        }
        else if (contentEncoding !== encoding) {
            throw new Error(`mixed encoding of subject lines, expected [${contentEncoding}], received [${encoding}]`);
        }
        if (contentCharset == null) {
            contentCharset = charset;
        }
        else if (contentCharset !== charset) {
            throw new Error(`mixed charset of subject lines, expected [${contentCharset}], received [${charset}]`);
        }
        encodedContent += encodedText;
    }
    let decodedContent = null;
    if (contentEncoding === 'B') {
        decodedContent = encoding.decodeBase64(encodedContent);
    }
    let charsetEncodedContent = null;
    if (decodedContent) {
        if ((contentCharset === null || contentCharset === void 0 ? void 0 : contentCharset.toUpperCase()) === 'UTF-8') {
            charsetEncodedContent = encoding.encodeUtf8(decodedContent);
        }
    }
    // Note: to handle legacy, used to have incorrect subject formatting with encodeUriComponent(...). This is "best effort" to handle it.
    if (charsetEncodedContent && charsetEncodedContent.indexOf('%') > -1) {
        try {
            return decodeURIComponent(charsetEncodedContent);
        }
        catch (e) {
            // ignore it, not URI Component
        }
    }
    return charsetEncodedContent !== null && charsetEncodedContent !== void 0 ? charsetEncodedContent : encodedContent;
}
function parseIdentityKeys(attrStr) {
    const result = new Map();
    for (const attrPairStr of attrStr.split(';')) {
        // attrPairStr: alice@mailchain.com="0x192382039fu89sdf82u893123:mailchain"
        const [attrKey, quotedValue] = attrPairStr.trim().split('=');
        if (attrKey == null || attrKey.length === 0 || quotedValue == null || quotedValue.length === 0)
            continue;
        const value = quotedValue.substring(1, quotedValue.length - 1); // remote the quotes from "0x192382039fu89sdf82u893123:mailchain"
        if (attrKey === 'v') {
            // This is the version attribute, example: v=1
            if (value !== '1') {
                console.warn(`unsupported ${consts.X_IDENTITY_KEYS} version of [${value}]`);
                return new Map();
            }
        }
        else {
            const [encodedIdentityKey, protocol] = value.split(':');
            if (!addressing.ALL_PROTOCOLS.includes(protocol)) {
                console.warn(`address [${attrKey}] has unsupported protocol [${protocol}]`);
            }
            try {
                const identityKey = crypto.decodePublicKey(encoding.decodeHexZeroX(encodedIdentityKey));
                result.set(attrKey, Object.assign({ identityKey, protocol: protocol }));
            }
            catch (e) {
                console.warn(`failed decoding identity key of address [${attrKey}] for value [${encodedIdentityKey}]`, e);
            }
        }
    }
    return result;
}

exports.parseMimeText = parseMimeText;
